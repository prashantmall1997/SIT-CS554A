const mongoCollections = require("../config/mongoCollections");
const blogApiData = mongoCollections.blogApiData;
var ObjectID = require("mongodb").ObjectId;

async function idFormatChecker(id) {
  if (id === undefined) {
    throw {
      status: 400,
      error: "ID parameter not passed - Generated by '/data/blogApiData.js'.",
    };
  }

  if (typeof id != "string") {
    throw {
      status: 400,
      error:
        "ID paramenter must be passed in string format from URL - Generated by '/data/blogApiData.js'.",
    };
  }

  if (!ObjectID.isValid(id)) {
    throw {
      status: 400,
      error:
        "ID paramenter passed in string format from URL is not a valid ObjectID - Generated by '/data/blogApiData.js'.",
    };
  }
}

const exportedMethods = {
  async getBlogs(skip, take) {
    try {
      if (
        (parseInt(skip) === NaN || parseInt(skip).toString() !== skip) &&
        skip !== null
      ) {
        throw {
          status: 400,
          error:
            "Skip should be an integer - Generated by '/data/blogApiData.js'.",
        };
      }

      if (parseInt(skip) <= 0) {
        throw {
          status: 400,
          error:
            "Skip should be a positive integer - Generated by '/data/blogApiData.js'.",
        };
      }

      if (
        (parseInt(take) === NaN || parseInt(take).toString() !== take) &&
        take !== null
      ) {
        throw {
          status: 400,
          error:
            "Take should be an integer - Generated by '/data/blogApiData.js'.",
        };
      }

      if (parseInt(take) <= 0) {
        throw {
          status: 400,
          error:
            "Take should be a positive integer - Generated by '/data/blogApiData.js'.",
        };
      }
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      parseInt(take) > 100 ? (take = 100) : null;
      const blogApiCollection = await blogApiData();
      if (skip !== null && take !== null) {
        return await blogApiCollection
          .find()
          .skip(parseInt(skip))
          .limit(parseInt(take))
          .toArray();
      } else if (skip !== null) {
        return await blogApiCollection
          .find()
          .skip(parseInt(skip))
          .limit(20)
          .toArray();
      } else if (take !== null) {
        return await blogApiCollection.find().limit(parseInt(take)).toArray();
      } else {
        return await blogApiCollection.find().limit(20).toArray();
      }
    } catch (e) {
      if (e.status && e.error) {
        throw { status: e.status, error: e.error };
      } else {
        throw { status: 500, error: e };
      }
    }
  },
  async postBlog(title, body, user) {
    try {
      if (!title || title === undefined || !body || body === undefined) {
        throw {
          status: 400,
          error:
            "Must provide blog title and body - Generated by '/data/blogApiData.js'.",
        };
      }

      if (typeof title != "string") {
        throw {
          status: 400,
          error:
            "Blog title must be provided in string format - Generated by '/data/blogApiData.js'.",
        };
      }
      if (title.trim() === "") {
        throw {
          status: 400,
          error:
            "Blog title cannot be empty string or just blank spaces - Generated by '/data/blogApiData.js'.",
        };
      }

      if (typeof body != "string") {
        throw {
          status: 400,
          error:
            "Blog body must be provided in string format - Generated by '/data/blogApiData.js'.",
        };
      }
      if (body.trim() === "") {
        throw {
          status: 400,
          error:
            "Blog body cannot be empty string or just blank spaces - Generated by '/data/blogApiData.js'.",
        };
      }

      if (
        user._id.trim() === "" ||
        user._id === undefined ||
        user.username.trim() === "" ||
        user.username === undefined
      ) {
        throw {
          status: 400,
          error:
            "Session cookie does not contain proper data - Generated by '/data/blogApiData.js'.",
        };
      }
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    const formattedBlog = {
      title: title.trim(),
      body: body.trim(),
      userThatPosted: { _id: ObjectID(user._id), username: user.username },
      comments: [],
    };
    try {
      const blogApiCollection = await blogApiData();

      const newInsertInformation = await blogApiCollection.insertOne(
        formattedBlog
      );

      if (newInsertInformation.insertedCount === 0)
        throw {
          status: 500,
          error:
            "Failed to add blog to DB - Generated by '/data/blogApiData.js'.",
        };

      const insertedBlog = await this.getBlogById(
        newInsertInformation.insertedId.toString()
      );
      insertedBlog._id = insertedBlog._id.toString();

      return insertedBlog;
    } catch (e) {
      if (e.status && e.error) {
        throw { status: e.status, error: e.error };
      } else {
        throw { status: 500, error: e };
      }
    }
  },
  async getBlogById(id) {
    try {
      await idFormatChecker(id);
    } catch (e) {
      throw {
        status: e.status,
        error: e.error,
      };
    }

    try {
      const blogApiCollection = await blogApiData();
      const blog = await blogApiCollection.findOne({ _id: ObjectID(id) });

      if (!blog) {
        throw {
          status: 404,
          error: `No blog found with _id of ${id}`,
        };
      } else {
        return blog;
      }
    } catch (e) {
      if (e.status && e.error) {
        throw { status: e.status, error: e.error };
      } else {
        throw { status: 500, error: e };
      }
    }
  },

  async updateBlog(title, body, id) {
    try {
      await idFormatChecker(id);

      if (!title || title === undefined || !body || body === undefined) {
        throw {
          status: 400,
          error:
            "Must provide blog title and body - Generated by '/data/blogApiData.js'.",
        };
      }

      if (typeof title != "string") {
        throw {
          status: 400,
          error:
            "Blog title must be provided in string format - Generated by '/data/blogApiData.js'.",
        };
      }
      if (title.trim() === "") {
        throw {
          status: 400,
          error:
            "Blog title cannot be empty string or just blank spaces - Generated by '/data/blogApiData.js'.",
        };
      }

      if (typeof body != "string") {
        throw {
          status: 400,
          error:
            "Blog body must be provided in string format - Generated by '/data/blogApiData.js'.",
        };
      }
      if (body.trim() === "") {
        throw {
          status: 400,
          error:
            "Blog body cannot be empty string or just blank spaces - Generated by '/data/blogApiData.js'.",
        };
      }
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      const blogToUpdate = await this.getBlogById(id);

      var blogData = {
        title: title,
        body: body,
        userThatPosted: {
          _id: ObjectID(blogToUpdate.userThatPosted._id),
          username: blogToUpdate.userThatPosted.username,
        },
        comments: blogToUpdate.comments,
      };

      blogData.comments.forEach(
        (comment) => (comment._id = ObjectID(comment._id))
      );
      delete blogToUpdate._id;

      if (JSON.stringify(blogToUpdate) === JSON.stringify(blogData)) {
        throw {
          status: 400,
          error: `Blog found with ID '${id}' has not been updated as no new values has been provided - Generated by '/data/blogApiData.js'. `,
        };
      }

      const blogApiCollection = await blogApiData();

      const updateBlog = await blogApiCollection.updateOne(
        { _id: ObjectID(id) },
        { $set: blogData }
      );

      if (updateBlog.modifiedCount === 0) {
        throw {
          status: 500,
          error: `Blog found with ID '${id}' has not been updated - Generated by '/data/blogApiData.js'. `,
        };
      }

      const updatedBlog = await this.getBlogById(id);
      return updatedBlog;
    } catch (e) {
      if (e.status && e.error) {
        throw { status: e.status, error: e.error };
      } else {
        throw { status: 500, error: e };
      }
    }
  },

  async patchBlog(title, body, id) {
    try {
      await idFormatChecker(id);

      if ((!title || title === undefined) && (!body || body === undefined)) {
        throw {
          status: 400,
          error:
            "Must provide either blog title or body - Generated by '/data/blogApiData.js'.",
        };
      }

      if (title && title != undefined) {
        if (typeof title != "string") {
          throw {
            status: 400,
            error:
              "Blog title must be provided in string format - Generated by '/data/blogApiData.js'.",
          };
        }
        if (title.trim() === "") {
          throw {
            status: 400,
            error:
              "Blog title cannot be empty string or just blank spaces - Generated by '/data/blogApiData.js'.",
          };
        }
      }

      if (body && body != undefined) {
        if (typeof body != "string") {
          throw {
            status: 400,
            error:
              "Blog body must be provided in string format - Generated by '/data/blogApiData.js'.",
          };
        }
        if (body.trim() === "") {
          throw {
            status: 400,
            error:
              "Blog body cannot be empty string or just blank spaces - Generated by '/data/blogApiData.js'.",
          };
        }
      }
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      const blogToUpdate = await this.getBlogById(id);

      if (title === undefined) {
        title = blogToUpdate.title;
      }
      if (body === undefined) {
        body = blogToUpdate.body;
      }

      var blogData = {
        title: title,
        body: body,
        userThatPosted: {
          _id: ObjectID(blogToUpdate.userThatPosted._id),
          username: blogToUpdate.userThatPosted.username,
        },
        comments: blogToUpdate.comments,
      };

      blogData.comments.forEach(
        (comment) => (comment._id = ObjectID(comment._id))
      );
      delete blogToUpdate._id;

      if (JSON.stringify(blogToUpdate) === JSON.stringify(blogData)) {
        throw {
          status: 400,
          error: `Blog found with ID '${id}' has not been updated as no new values has been provided - Generated by '/data/blogApiData.js'. `,
        };
      }

      const blogApiCollection = await blogApiData();

      const updateBlog = await blogApiCollection.updateOne(
        { _id: ObjectID(id) },
        { $set: blogData }
      );

      if (updateBlog.modifiedCount === 0) {
        throw {
          status: 500,
          error: `Blog found with ID '${id}' has not been updated - Generated by '/data/blogApiData.js'. `,
        };
      }

      const updatedBlog = await this.getBlogById(id);
      return updatedBlog;
    } catch (e) {
      if (e.status && e.error) {
        throw { status: e.status, error: e.error };
      } else {
        throw { status: 500, error: e };
      }
    }
  },

  async postComment(blogID, comment, user) {
    try {
      await idFormatChecker(blogID);
      if (!comment || comment === undefined) {
        throw {
          status: 400,
          error: "Must provide comment - Generated by '/data/blogApiData.js'.",
        };
      }

      if (typeof comment != "string") {
        throw {
          status: 400,
          error:
            "Blog comment must be provided in string format - Generated by '/data/blogApiData.js'.",
        };
      }
      if (comment.trim() === "") {
        throw {
          status: 400,
          error:
            "Blog comment cannot be empty string or just blank spaces - Generated by '/data/blogApiData.js'.",
        };
      }
    } catch (e) {
      res.status(e.status).send({ error: e.error });
      return;
    }

    try {
      const blogApiCollection = await blogApiData();

      await this.getBlogById(blogID);

      const blog = await blogApiCollection.updateOne(
        { _id: ObjectID(blogID) },
        {
          $push: {
            comments: {
              _id: new ObjectID(),
              userThatPostedComment: {
                _id: ObjectID(user._id),
                username: user.username,
              },
              comment: comment,
            },
          },
        }
      );
      if (blog.modifiedCount !== 1) {
        throw {
          status: 500,
          error: `Blog comment has not been posted - Generated by '/data/blogApiData.js'. `,
        };
      } else {
        return { message: "Comment posted!" };
      }
    } catch (e) {
      if (e.status && e.error) {
        throw { status: e.status, error: e.error };
      } else {
        throw { status: 500, error: e };
      }
    }
  },

  async deleteComment(blogID, commentID) {
    try {
      await idFormatChecker(blogID);
      await idFormatChecker(commentID);
    } catch (e) {
      res.status(e.status).send({ error: e.error });
      return;
    }
    try {
      const blogApiCollection = await blogApiData();

      const comment = await blogApiCollection.updateOne(
        { _id: ObjectID(blogID) },
        {
          $pull: { comments: { _id: ObjectID(commentID) } },
        }
      );

      if (comment.modifiedCount !== 1) {
        throw {
          status: 500,
          error: `Blog comment has not been deleted - Generated by '/data/blogApiData.js'. `,
        };
      } else {
        return { message: "Comment deleted!" };
      }
    } catch (e) {
      if (e.status && e.error) {
        throw { status: e.status, error: e.error };
      } else {
        throw { status: 500, error: e };
      }
    }
  },
};

module.exports = exportedMethods;
