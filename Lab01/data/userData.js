const mongoCollections = require("../config/mongoCollections");
const userData = mongoCollections.userData;
var ObjectID = require("mongodb").ObjectID;
const bcrypt = require("bcrypt");

const exportedMethods = {
  async signup(user) {
    try {
      if (!user.name || !user.username || !user.password) {
        throw {
          status: 401,
          error:
            "Name, Username & Password must be provided! - Generated by '/data/userData.js'.",
        };
      }

      if (typeof user.name != "string") {
        throw {
          status: 400,
          error:
            "User's name must be provided in string format - Generated by '/data/userData.js'.",
        };
      }
      if (user.name.trim() === "") {
        throw {
          status: 400,
          error:
            "User's name cannot be empty string or just blank spaces - Generated by '/data/userData.js'.",
        };
      }

      if (typeof user.username != "string") {
        throw {
          status: 400,
          error:
            "User's username must be provided in string format - Generated by '/data/userData.js'.",
        };
      }
      if (user.username.trim() === "") {
        throw {
          status: 400,
          error:
            "User's username cannot be empty string or just blank spaces - Generated by '/data/userData.js'.",
        };
      }

      if (typeof user.password != "string") {
        throw {
          status: 400,
          error:
            "User's password must be provided in string format - Generated by '/data/userData.js'.",
        };
      }
      if (user.password.trim() === "") {
        throw {
          status: 400,
          error:
            "User's password cannot be empty string or just blank spaces - Generated by '/data/userData.js'.",
        };
      }
    } catch (e) {
      res.status(e.status).send({ error: e.error });
      return;
    }

    try {
      const userCollection = await userData();

      const userExist = await userCollection.findOne({
        username: user.username,
      });

      if (userExist) {
        return "usernameNotAvailable";
      } else {
        return await userCollection.insertOne(user);
      }
    } catch (e) {
      if (e.status && e.error) {
        throw { status: e.status, error: e.error };
      } else {
        throw { status: 500, error: e };
      }
    }
  },

  async login(user) {
    try {
      if (!user.username || !user.password) {
        throw {
          status: 401,
          error:
            "Name, Username & Password must be provided! - Generated by '/data/userData.js'.",
        };
      }

      if (typeof user.username != "string") {
        throw {
          status: 400,
          error:
            "User's username must be provided in string format - Generated by '/data/userData.js'.",
        };
      }
      if (user.username.trim() === "") {
        throw {
          status: 400,
          error:
            "User's username cannot be empty string or just blank spaces - Generated by '/data/userData.js'.",
        };
      }

      if (typeof user.password != "string") {
        throw {
          status: 400,
          error:
            "User's password must be provided in string format - Generated by '/data/userData.js'.",
        };
      }
      if (user.password.trim() === "") {
        throw {
          status: 400,
          error:
            "User's password cannot be empty string or just blank spaces - Generated by '/data/userData.js'.",
        };
      }
    } catch (e) {
      res.status(e.status).send({ error: e.error });
      return;
    }

    try {
      const userCollection = await userData();

      const userExist = await userCollection.findOne({
        username: user.username,
      });

      if (!userExist) {
        return "userDoesNotExist";
      }

      comparePassword = await bcrypt.compare(user.password, userExist.password);

      if (comparePassword === true) {
        return ["success", userExist._id];
      } else {
        return "fail";
      }
    } catch (e) {
      if (e.status && e.error) {
        res.status(e.status).send({ error: e.error });
      } else {
        res.status(500).send({ e });
      }
    }
  },
};

module.exports = exportedMethods;
